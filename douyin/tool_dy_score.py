import random
import re

import pandas as pd
import time


def 计算下一次运行等待秒数(
    df, 两次运行最小间隔秒数=5 * 60, 每小时最多运行次数=8, 当前时间=None
):
    """
    根据历史运行记录和约束条件，计算下一次运行需要等待的秒数

    核心约束逻辑：
    1. 最小间隔约束：两次运行必须间隔至少「两次运行最小间隔秒数」
    2. 每小时上限约束：任意连续1小时窗口内运行次数不能超过「每小时最多运行次数」
       - 计算逻辑：找到第N-1次运行的时间（N=每小时最多运行次数），判断该时间与当前时间的差值
       - 若差值 < 1小时：需等待到「第N-1次运行时间 + 1小时 - 当前时间」，再叠加最小间隔约束
       - 若差值 ≥ 1小时：仅需满足最小间隔约束即可

    参数：
    df: pandas.DataFrame - 包含"时间"列的DataFrame，值为time.time()结果，且按升序排列
    两次运行最小间隔秒数: int - 基础最小间隔，默认300秒（5分钟）
    每小时最多运行次数: int - 每小时运行次数上限，默认8次
    当前时间: int/float/None - 当前时间戳（用于测试），None时自动取time.time()

    返回：
    int - 下一次运行需要sleep的秒数（向上取整）

    单元测试示例：
    >>> import pandas as pd
    >>> # 示例1：无历史记录（空DataFrame）→ 立即运行
    >>> df_empty = pd.DataFrame(columns=["时间"])
    >>> 计算下一次运行等待秒数(df_empty, 当前时间=1740000000)
    0

    >>> # 示例2：8次运行，第7次（索引6）在当前时间前3500秒（<3600）→ 需等100+300=400秒
    >>> times_2 = [1740000000 - 500*i for i in range(8)]  # 8条记录：0,500,1000,1500,2000,2500,3000,3500秒前
    >>> df2 = pd.DataFrame({"时间": times_2})
    >>> 计算下一次运行等待秒数(df2, 当前时间=1740000000)
    300

    >>> # 示例3：8次运行，第7次在当前时间前3700秒（≥3600）→ 仅需最小间隔（最后一次200秒前→等100秒）
    >>> times_3 = [1740000000 - (3700 + 100*i) for i in range(8)]  # 第7次3700秒前，最后一次3000秒前
    >>> df3 = pd.DataFrame({"时间": times_3})
    >>> 计算下一次运行等待秒数(df3, 当前时间=1740000000)
    0

    >>> # 示例4：10次运行，找第8次（索引8）→ 3500秒前→等100+300=400秒
    >>> times_4 = [1740000000 - 400*i for i in range(10)]  # 第8次3500秒前，最后一次3600秒前
    >>> df4 = pd.DataFrame({"时间": times_4})
    >>> 计算下一次运行等待秒数(df4, 当前时间=1740000000)
    800

    >>> # 示例5：未达上限（5次）→ 仅按最小间隔（最后一次200秒前→等100秒）
    >>> times_5 = [1740000000 - 200*i for i in range(5)]
    >>> df5 = pd.DataFrame({"时间": times_5})
    >>> 计算下一次运行等待秒数(df5, 当前时间=1740000000)
    300

    >>> # 示例6：自定义参数（每小时最多5次，最小间隔400秒）→ 第4次3500秒前→等100+400=500秒
    >>> times_6 = [1740000000 - 700*i for i in range(5)]  # 第4次3500秒前，最后一次2800秒前
    >>> df6 = pd.DataFrame({"时间": times_6})
    >>> 计算下一次运行等待秒数(df6, 两次运行最小间隔秒数=400, 每小时最多运行次数=5, 当前时间=1740000000)
    800

    """
    # 1. 处理当前时间参数（统一为浮点数）
    if 当前时间 is None:
        current_time = time.time()
    else:
        current_time = float(当前时间)

    # 2. 校验DataFrame列完整性
    if "时间" not in df.columns:
        raise ValueError('DataFrame必须包含名为"时间"的列')

    # 3. 处理无历史记录场景（首次运行无需等待）
    if df.empty:
        return 0

    df = df.sort_values("时间")

    df = df[df.时间 >= current_time - 3600]

    if df.empty:
        return 0

    # 4. 核心变量初始化
    last_run_time = df["时间"].iloc[-1]  # 最后一次运行时间
    run_count_total = len(df)  # 总运行次数
    hour_seconds = 3600  # 1小时的秒数
    max_hourly = 每小时最多运行次数  # 每小时最多运行次数
    min_interval = 两次运行最小间隔秒数  # 最小间隔秒数

    # 5. 计算每小时上限约束的等待时间
    hour_constraint_wait = 0  # 初始化每小时约束的等待时间
    if run_count_total >= max_hourly:
        # 从最新的记录往前找第max_hourly-1次运行的时间（索引：-max_hourly）
        # 例如max_hourly=8 → 找倒数第8条（索引-8），即第7次运行时间
        target_index = -max_hourly
        target_run_time = df["时间"].iloc[target_index]

        # 计算目标运行时间与当前时间的差值
        time_diff = current_time - target_run_time

        # 若差值 < 1小时 → 需等待到目标运行时间+1小时
        if time_diff < hour_seconds:
            hour_constraint_wait = (target_run_time + hour_seconds) - current_time

    # 6. 计算最小间隔约束的等待时间
    min_interval_wait = max(0, (last_run_time + min_interval) - current_time)

    # 7. 最终等待时间取两者最大值（需同时满足两个约束）
    wait_seconds = max(hour_constraint_wait, min_interval_wait)

    # 8. 转换为整数返回（秒数取整，round处理浮点精度问题）
    return int(round(wait_seconds))


def 精确获取文本中的数字(txt):
    """
    从文本中提取数字，支持两种格式：
    1. 纯数字（如3133）直接返回整数
    2. 带万的数字（如123.4万/1万）转换为具体数值后返回整数
    若文本中无数字，返回None

    >>> 精确获取文本中的数字("未点赞，喜欢3133，按钮")
    3133
    >>> 精确获取文本中的数字("评论581，按钮")
    581
    >>> 精确获取文本中的数字("未选中，收藏202，按钮")
    202
    >>> 精确获取文本中的数字("分享363，按钮")
    363
    >>> 精确获取文本中的数字("未点赞，喜欢123.4万，按钮")
    1234000
    >>> 精确获取文本中的数字("评论2.5万，按钮")
    25000
    >>> 精确获取文本中的数字("未选中，收藏3.2万，按钮")
    32000
    >>> 精确获取文本中的数字("分享17.1万，按钮")
    171000
    >>> 精确获取文本中的数字("收藏1万，按钮")  # 无小数点的万单位
    10000
    >>> 精确获取文本中的数字("纯文本无数字")
    0
    >>> 精确获取文本中的数字("数字在开头123abc")
    123
    >>> 精确获取文本中的数字("数字在末尾abc456")
    456
    """
    # 正则匹配规则：
    # 分组1：带万的数字（支持 1万、1.2万 格式）
    # 分组2：纯数字（如 3133）
    pattern = r"(\d+(?:\.\d+)?)万|(\d+)"
    match_result = re.search(pattern, txt)

    if not match_result:
        return 0

    # 提取匹配结果的分组值
    wan_num_str = match_result.group(1)  # 带万的数字部分（如123.4）
    pure_num_str = match_result.group(2)  # 纯数字部分（如3133）

    if wan_num_str:
        # 万单位转换：数字 * 10000 后转整数
        return int(float(wan_num_str) * 10000)
    else:
        # 纯数字直接转整数
        return int(pure_num_str)


# def 计算评论价值评分(
#     评论数: int, 点赞数: int, 转发: int, 收藏: int, 是否有广告: bool
# ) -> float:
#     """
#     根据抖音视频核心数据计算评论价值评分（0-100分），评分越高越适合评论涨粉
#     核心逻辑（贴合实际运营经验）：
#     - 评论数/点赞数≤10的作品作者最易关注我们，是核心涨粉来源
#     - 收藏/转发为辅助维度，权重更低
#     - 无广告视频转化阻力更小

#     权重分配：
#     - 评论数：40%（核心维度，≤10条时涨粉效率最高）
#     - 点赞数：35%（核心维度，≤10个时作者互动意愿最强）
#     - 收藏数：10%（辅助维度，仅作补充参考）
#     - 转发数：5%（弱辅助维度）
#     - 是否有广告：10%（影响转化阻力）

#     各维度评分规则（0-100分）：
#     1. 评论数：≤10→100分 | 11-50→50分 | >50→10分 | ≤0→0分
#     2. 点赞数：≤10→100分 | 11-50→50分 | >50→10分 | ≤0→0分
#     3. 收藏数：>50→100分 | 21-50→70分 | ≤20→20分 | ≤0→0分
#     4. 转发数：>20→100分 | 11-20→70分 | ≤10→20分 | ≤0→0分
#     5. 是否有广告：无广告→100分 | 有广告→20分

#     单元测试案例：
#     >>> round(计算评论价值评分(100, 100, 0, 0, True), 1) < 60  # 极端案例：完全不适合（接近0）
#     True
#     >>> round(计算评论价值评分(5, 8, 15, 30, False), 1) > 60  # 优秀案例：90-100分
#     True
#     >>> round(计算评论价值评分(10, 10, 8, 15, False), 1) > 60  # 优良案例：70-80分
#     True
#     >>> v = round(计算评论价值评分(11, 11, 5, 10, False), 1)  # 及格线案例：≈60分
#     >>> v > 60 and v < 70
#     True
#     >>> round(计算评论价值评分(50, 50, 3, 8, True), 1) < 60   # 不及格案例：10-59分
#     True
#     >>> round(计算评论价值评分(0, 0, 0, 0, False), 1) < 60  # 优秀案例：90-100分
#     True
#     >>> round(计算评论价值评分(1, 1, 1, 1, False), 1) > 60  # 优秀案例：90-100分
#     True
#     >>> round(计算评论价值评分(1, 1, 0, 0, False), 1) > 60   # 优秀案例：90-100分
#     True
#     >>> round(计算评论价值评分(1, 1, 0, 0, True), 1) < 60  # 优秀案例：90-100分
#     True
#     """
#     # 1. 评论数维度得分（核心：≤10分最高）
#     if 评论数 <= 100:
#         评论数得分 = 50.0
#     elif 评论数 <= 50:
#         评论数得分 = 100.0
#     else:
#         评论数得分 = 10.0

#     # 2. 点赞数维度得分（核心：≤10分最高）
#     if 点赞数 <= 0:
#         点赞数得分 = 50.0
#     elif 点赞数 <= 50:
#         点赞数得分 = 100.0
#     elif 点赞数 <= 100:
#         点赞数得分 = 50.0
#     else:
#         点赞数得分 = 10.0

#     # 3. 收藏数维度得分（辅助）
#     if 收藏 <= 0:
#         收藏得分 = 0.0
#     elif 收藏 <= 20:
#         收藏得分 = 20.0
#     elif 收藏 <= 50:
#         收藏得分 = 70.0
#     else:
#         收藏得分 = 100.0

#     # 4. 转发数维度得分（弱辅助）
#     if 转发 <= 0:
#         转发得分 = 0.0
#     elif 转发 <= 10:
#         转发得分 = 20.0
#     elif 转发 <= 20:
#         转发得分 = 70.0
#     else:
#         转发得分 = 100.0

#     # 5. 广告维度得分
#     广告得分 = 60.0 if not 是否有广告 else -100.0

#     # 加权计算总分（核心权重向评论数/点赞数倾斜）
#     总分 = (
#         评论数得分 * 0.40  # 评论数权重40%
#         + 点赞数得分 * 0.35  # 点赞数权重35%
#         + 收藏得分 * 0.10  # 收藏权重10%
#         + 转发得分 * 0.05  # 转发权重5%
#         + 广告得分 * (0.33 if 广告得分 >= 0 else 0.5)  # 广告权重10%
#     )

#     # 强制限制得分在0-100区间
#     最终得分 = max(0.0, min(100.0, 总分))

#     # 最终得分 = 0 if 是否有广告 else 最终得分
#     if not 是否有广告 and 评论数 < 100 and 点赞数 < 100:
#         最终得分 = 100
#     else:
#         最终得分 = 0

#     return 最终得分


def 计算评论价值评分(
    评论数: int, 点赞数: int, 转发: int, 收藏: int, 是否有广告: bool, 随机数: int = 0
) -> float:
    """
    计算评论的价值评分，遵循以下优先级规则（从高到低）：

    规则：
    1. 是否有广告为True → 返回0.0
    2. 评论数/点赞数/转发/收藏任意一个>100 → 返回0.0
    3. 随机数为0时，自动生成1-99的随机整数
    4. 评论数或点赞数不超过随机数 → 返回0.0
    5. 所有条件不满足 → 返回100.0
    """
    # 第一步：优先判断是否有广告（最高优先级）
    if 是否有广告:
        return 0.0

    # 第二步：判断是否有指标超过100
    if 评论数 > 100 or 点赞数 > 100 or 转发 > 100 or 收藏 > 100:
        return 0.0

    # 第三步：处理随机数（默认0时生成1-99的整数）
    if 随机数 == 0:
        随机数 = random.randint(1, 30)
        print(f'--------------随机数:{随机数}----------------------')


    # 第四步：判断评论数/点赞数是否超过随机数
    if 点赞数+评论数+转发+收藏 < 随机数:
        return 0.0

    # 所有条件都不满足，返回100.0（float类型）
    return 100.0


# 执行单元测试
if __name__ == "__main__":
    import doctest

    print(doctest.testmod(verbose=False, report=False))
